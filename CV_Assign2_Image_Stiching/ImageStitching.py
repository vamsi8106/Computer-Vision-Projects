# -*- coding: utf-8 -*-
"""M22RM002_Q3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1adk7pj4dHzRc-2jCDA5qjWGaQ_m4ScOj
"""

import cv2
import numpy
import os
import math
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow

from google.colab import drive
drive.mount('/content/drive')

"""METHOD-1

"""

import cv2
import numpy as np
import sys
import imutils


class Image_Stitching():
    def __init__(self) :
        self.ratio=0.85
        self.min_match=10
        self.sift=cv2.xfeatures2d.SIFT_create()
        self.smoothing_window_size=800

    def registration(self,img1,img2):
        kp1, des1 = self.sift.detectAndCompute(img1, None)
        kp2, des2 = self.sift.detectAndCompute(img2, None)
        matcher = cv2.BFMatcher()
        raw_matches = matcher.knnMatch(des1, des2, k=2)
        good_points = []
        good_matches=[]
        for m1, m2 in raw_matches:
            if m1.distance < self.ratio * m2.distance:
                good_points.append((m1.trainIdx, m1.queryIdx))
                good_matches.append([m1])
        img3 = cv2.drawMatchesKnn(img1, kp1, img2, kp2, good_matches, None, flags=2)
        cv2.imwrite('matching.jpg', img3)
        if len(good_points) > self.min_match:
            image1_kp = np.float32(
                [kp1[i].pt for (_, i) in good_points])
            image2_kp = np.float32(
                [kp2[i].pt for (i, _) in good_points])
            H, status = cv2.findHomography(image2_kp, image1_kp, cv2.RANSAC,5.0)
        return H

    def create_mask(self,img1,img2,version):
        height_img1 = img1.shape[0]
        width_img1 = img1.shape[1]
        width_img2 = img2.shape[1]
        height_panorama = height_img1
        width_panorama = width_img1 +width_img2
        offset = int(self.smoothing_window_size / 2)
        barrier = img1.shape[1] - int(self.smoothing_window_size / 2)
        mask = np.zeros((height_panorama, width_panorama))
        if version== 'left_image':
            mask[:, barrier - offset:barrier + offset ] = np.tile(np.linspace(1, 0, 2 * offset ).T, (height_panorama, 1))
            mask[:, :barrier - offset] = 1
        else:
            mask[:, barrier - offset :barrier + offset ] = np.tile(np.linspace(0, 1, 2 * offset ).T, (height_panorama, 1))
            mask[:, barrier + offset:] = 1
        return cv2.merge([mask, mask, mask])

    def blending(self,img1,img2):
        H = self.registration(img1,img2)
        height_img1 = img1.shape[0]
        width_img1 = img1.shape[1]
        width_img2 = img2.shape[1]
        height_panorama = height_img1
        width_panorama = width_img1 +width_img2

        panorama1 = np.zeros((height_panorama, width_panorama, 3))
        mask1 = self.create_mask(img1,img2,version='left_image')
        panorama1[0:img1.shape[0], 0:img1.shape[1], :] = img1
        panorama1 *= mask1
        mask2 = self.create_mask(img1,img2,version='right_image')
        panorama2 = cv2.warpPerspective(img2, H, (width_panorama, height_panorama))*mask2
        result=panorama1+panorama2

        rows, cols = np.where(result[:, :, 0] != 0)
        min_row, max_row = min(rows), max(rows) + 1
        min_col, max_col = min(cols), max(cols) + 1
        final_result = result[min_row:max_row, min_col:max_col, :]
        return final_result

dim=(1000,700)
left=cv2.imread('/content/drive/MyDrive/problem-3/1a.jpeg',cv2.IMREAD_COLOR)
left=cv2.resize(left,dim,interpolation = cv2.INTER_AREA)   
right=cv2.imread('/content/drive/MyDrive/problem-3/1b.jpeg',cv2.IMREAD_COLOR)
right=cv2.resize(right,dim,interpolation = cv2.INTER_AREA)
last=cv2.imread('/content/drive/MyDrive/problem-3/1c.jpeg',cv2.IMREAD_COLOR)
last=cv2.resize(last,dim,interpolation = cv2.INTER_AREA) 
img1 = left
img2 = right
final=Image_Stitching().blending(img1,img2)
cv2.imwrite('/content/drive/MyDrive/problem-3/p1.jpeg', final)

img1=cv2.imread("/content/drive/MyDrive/problem-3/p1.jpeg")
img1=cv2.resize(img1,dim,interpolation = cv2.INTER_AREA)   
img2=cv2.imread("/content/drive/MyDrive/problem-3/1c.jpeg")
img2=cv2.resize(img2,dim,interpolation = cv2.INTER_AREA)   
final=Image_Stitching().blending(img1,img2)
cv2_imshow(final)

"""METHOD-2"""

def stitcher(images):
  stitcher = cv2.Stitcher.create()
  ret,pano = stitcher.stitch(images)
  return pano

def post_process(pano):
    pano = cv2.copyMakeBorder(pano, 10, 10, 10, 10, cv2.BORDER_CONSTANT, (0,0,0))
    gray = cv2.cvtColor(pano, cv2.COLOR_BGR2GRAY)
    thresh_img = cv2.threshold(gray, 0, 255 , cv2.THRESH_BINARY)[1]
    contours = cv2.findContours(thresh_img.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    contours = imutils.grab_contours(contours)
    areaOI = max(contours, key=cv2.contourArea)
    mask = np.zeros(thresh_img.shape, dtype="uint8")
    x, y, w, h = cv2.boundingRect(areaOI)
    cv2.rectangle(mask, (x,y), (x + w, y + h), 255, -1)
    minRectangle = mask.copy()
    sub = mask.copy()
    while cv2.countNonZero(sub) > 0:
        minRectangle = cv2.erode(minRectangle, None)
        sub = cv2.subtract(minRectangle, thresh_img)
    contours = cv2.findContours(minRectangle.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    contours = imutils.grab_contours(contours)
    area= max(contours, key=cv2.contourArea)
    x, y, w, h = cv2.boundingRect(area)
    pano = pano[y:y + h, x:x + w]
    return pano

#Read the images from your directory
dim=(1000,700)
left=cv2.imread('/content/drive/MyDrive/problem-3/1a.jpeg',cv2.IMREAD_COLOR)
left=cv2.resize(left,dim,interpolation = cv2.INTER_AREA)   
right=cv2.imread('/content/drive/MyDrive/problem-3/1b.jpeg',cv2.IMREAD_COLOR)
right=cv2.resize(right,dim,interpolation = cv2.INTER_AREA)
last=cv2.imread('/content/drive/MyDrive/problem-3/1c.jpeg',cv2.IMREAD_COLOR)
last=cv2.resize(last,dim,interpolation = cv2.INTER_AREA) 
images=[]
images.append(left)
images.append(right)
images.append(last)
pano=stitcher(images)
pano=post_process(pano)

cv2_imshow(pano)

